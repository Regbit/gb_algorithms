1. Самым оптимальным оказался третий алгоритм с кэшированием (@functools.lru_cache()).
Хотя скорость его работы может быть нестабльной (от 231 nsec до 2.56 usec), он все равно в разы быстрее двух других.
Правда для этого алгоритма будут действовать ограничения по стеку вызова.
Поэтому финальное заключение об оптимальности алгоритма нужно строить исходя из конкретной задачи.

2. Примнение алгоритма "решето Эратосфена" явно оптимальнее и по времени работы (в ~4-5 раз) и по кол-ву вызовов функций.